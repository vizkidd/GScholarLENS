// async function getRetractionWatchDB() {
//   try {
//       return new Promise(resolve => {
//           chrome.storage.local.get("retractionwatchdb", (result) => {
//               resolve(result.retractionwatchdb || false);
//           });
//       });

//   }
//   catch (error) {
//       console.error("Error: Could not RetractionWatchDB blob data. " + error);
//       chrome.runtime.sendMessage({ type: 'release_semaphore' }, (response) => {
//           console.log(response.status);  // Should log "Semaphore released" 
//       });
//   }
// }

function sendZeroCopyArr(initZeroCopyArr) {
  const encoder = new TextEncoder();
  // 1) Turn to JSON
  const initJson = JSON.stringify(initZeroCopyArr);
  // 2) Encode as UTF-8 bytes in a Uint8Array
  const initBytes = encoder.encode(initJson); // Uint8Array


  // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
  //   self.postMessage({ type: 'working' , task: 'initialScrape', authorFound: authorFound, extended_scrape: extended_scrape, publication: publication }); // authorRegexes: authorRegexes
  self.postMessage(initBytes.buffer, [initBytes.buffer]);
}

self.onmessage = async ({ data }) => {
    const { task, batch, retractionWatchDB } = data;
    try {
        if (task === 'checkRetraction') {
        // const retractionWatchDB = await getRetractionWatchDB();
        for (const publication of batch) {
          let isPubRetracted = false;
          const pubTitle = publication.title;
          publication.retracted = false;
          // const pubTitle = element.title;
          const cleanPubTitle = pubTitle.toLowerCase().trim().replace(/[.,\/#!$%\^&\*;:}=\_\'\"\(\)\[\]\{\}\+-`~)]/g, '').replace(/\s+/g, '').replace(/retracted/g, '').replace(/retraction/g, '');
          // retractionProgress += 1;

          retractionWatchDB.map(async (entry) => {
              // retractionWatchDB.forEach(async (entry) => {
              if (isPubRetracted) {
                  // setTimeout(updateLoadingBar, 20, (retractionProgress / totalPublications) * 100, "Processing Retractions (" + retractionProgress + "): "); 
                  return;
              }
              const cleanEntryTitle = entry.Title.toLowerCase().trim().replace(/[.,\/#!$%\^&\*;:}=\_\'\"\(\)\[\]\{\}\+-`~)]/g, '').replace(/\s+/g, '').replace(/retracted/g, '').replace(/retraction/g, '');
              if (cleanPubTitle === cleanEntryTitle) {
                  // console.log("Retracted Publication:", pubTitle, entry.Title); //DEBUG
                  // retractedPubsIdxList.push(index);
                  // retractedPubsCount++;
                  isPubRetracted = true;
                  publication.retracted = true;
              }
              // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
          });
          // self.postMessage({ type: 'working', task: 'checkRetraction', publication: publication, isPubRetracted:isPubRetracted });
          const retractionResultArr = {
            type: 'working',
            task: 'checkRetraction',
            publication: publication,
            // isPubRetracted:isPubRetracted
          };
          sendZeroCopyArr(retractionResultArr);
        }
        // self.postMessage({ type: 'done', task:task });
        const taskCompleteArr = {
            type: 'done',
            task: task
          };
          sendZeroCopyArr(taskCompleteArr);
      }
    } catch (err) {
      // self.postMessage({ type: 'error', task, error: err.message });
      const taskErrorArr = {
            type: 'error',
            task: task,
            error: err.message 
          };
          sendZeroCopyArr(taskErrorArr);
    }
  };