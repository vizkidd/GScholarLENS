// This is a web worker script that processes publication data in batches.
function uniq(a) {
    return Array.from(new Set(a));
}

const replaceSpecialChars = (str) => {
  const charMap = {
      'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a', 'æ': 'ae', 'ā': 'a',
      'ç': 'c', 'ć': 'c', 'ĉ': 'c', 'č': 'c', 'ç': 'c', 'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e',
      'ē': 'e', 'ė': 'e', 'ę': 'e', 'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i', 'ī': 'i',
      'į': 'i', 'ı': 'i', 'ñ': 'n', 'ń': 'n', 'ň': 'n', 'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o',
      'ö': 'o', 'ø': 'o', 'ō': 'o', 'ó': 'o', 'œ': 'oe', 'ù': 'u', 'ú': 'u', 'û': 'u',
      'ü': 'u', 'ū': 'u', 'ý': 'y', 'ÿ': 'y', 'ž': 'z', 'ź': 'z', 'ż': 'z',
      'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A', 'Æ': 'AE', 'Ā': 'A',
      'Ç': 'C', 'Ć': 'C', 'Ĉ': 'C', 'Č': 'C', 'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E',
      'Ē': 'E', 'Ė': 'E', 'Ę': 'E', 'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I', 'Ī': 'I',
      'Į': 'I', 'İ': 'I', 'Ñ': 'N', 'Ń': 'N', 'Ň': 'N', 'Ò': 'O', 'Ó': 'O', 'Ô': 'O',
      'Õ': 'O', 'Ö': 'O', 'Ø': 'O', 'Ō': 'O', 'Œ': 'OE', 'Ù': 'U', 'Ú': 'U', 'Û': 'U',
      'Ü': 'U', 'Ū': 'U', 'Ý': 'Y', 'Ÿ': 'Y', 'Ž': 'Z', 'Ź': 'Z', 'Ż': 'Z', 'œ': 'oe',
      'ř': 'r', 'š': 's', 'ţ': 't', 'ū': 'u', 'ý': 'y'
  };

  return str.split('').map(char => charMap[char] || char).join('').replace(/[\u2010-\u2015\u2212\uFE58\u2043]/g, '-');
};

const normalizeString = (str) => {
  // Normalize the string to decomposed form (NFD), where characters with accents are split into their base character and combining mark.
  return str.normalize('NFD').replace(/[\u0300-\u036f]/g, "");
};

const cleanStringSpaces = (str) => str.replace(/\s+/g, ' ').trim();

// const areEqual = (a, b) =>
//     cleanStringSpaces(a.trim().normalize()).localeCompare(cleanStringSpaces(b.trim().normalize()), undefined, { sensitivity: 'base' }) === 0;

const cleanAndNormalize = (str) =>
    replaceSpecialChars(str)
        .normalize('NFC') // Normalize Unicode composition
        .replace(/\s+/g, ' ') // Collapse multiple spaces
        .trim() // Remove leading/trailing spaces
        .toLowerCase(); // Convert to lowercase

const areEqual = (a, b) =>
    cleanAndNormalize(a).localeCompare(cleanAndNormalize(b), undefined, { sensitivity: 'base' }) === 0;

function adjustIndexForSymbols(author_list, index) {
                // If ^ is present then authors share that position, we have to adjust the index to find the position shared by the authors
                let adj_i = index;
                while (adj_i > 0 && (author_list[adj_i].includes('^') || author_list[adj_i].includes('*'))) {
                    adj_i--;
                }
                return adj_i;
            }

function processAuthorPositions(yearwiseData, author, author_list, citationCount, index, qscore, year, publication) {
  // Process author positions and contributions
  const adj_i = adjustIndexForSymbols(author_list, index);
  let position = "NA";  // Assume NA as position by default

  if (!yearwiseData.get(year).has("author_pos_contrib")) {
      yearwiseData.get(year).set("author_pos_contrib", new Map());
      yearwiseData.get(year).get("author_pos_contrib").set("first_author", 0);
      yearwiseData.get(year).get("author_pos_contrib").set("second_author", 0);
      yearwiseData.get(year).get("author_pos_contrib").set("co_author", 0);
      yearwiseData.get(year).get("author_pos_contrib").set("corresponding_author", 0);
  }

  if (!yearwiseData.get(year).has("author_pos_cite_contrib")) {
      yearwiseData.get(year).set("author_pos_cite_contrib", new Map());
      yearwiseData.get(year).get("author_pos_cite_contrib").set("first_author", 0);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("second_author", 0);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("co_author", 0);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("corresponding_author", 0);
  }

  if (!yearwiseData.get(year).has("author_pos_cite_map")) {
      yearwiseData.get(year).set("author_pos_cite_map", new Map());
      yearwiseData.get(year).get("author_pos_cite_map").set("first_author", []);
      yearwiseData.get(year).get("author_pos_cite_map").set("second_author", []);
      yearwiseData.get(year).get("author_pos_cite_map").set("co_author", []);
      yearwiseData.get(year).get("author_pos_cite_map").set("corresponding_author", []);
  }

  if (!yearwiseData.get(year).has("author_pos_cite_qscore")) {
      yearwiseData.get(year).set("author_pos_cite_qscore", new Map());
      yearwiseData.get(year).get("author_pos_cite_qscore").set("first_author", new Map());
      yearwiseData.get(year).get("author_pos_cite_qscore").set("second_author", new Map());
      yearwiseData.get(year).get("author_pos_cite_qscore").set("co_author", new Map());
      yearwiseData.get(year).get("author_pos_cite_qscore").set("corresponding_author", new Map());
      yearwiseData.get(year).get("author_pos_cite_qscore").get("first_author").set("Q1", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("first_author").set("Q2", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("first_author").set("Q3", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("first_author").set("Q4", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("first_author").set("NA", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("second_author").set("Q1", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("second_author").set("Q2", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("second_author").set("Q3", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("second_author").set("Q4", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("second_author").set("NA", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("co_author").set("Q1", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("co_author").set("Q2", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("co_author").set("Q3", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("co_author").set("Q4", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("co_author").set("NA", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("corresponding_author").set("Q1", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("corresponding_author").set("Q2", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("corresponding_author").set("Q3", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("corresponding_author").set("Q4", 0);
      yearwiseData.get(year).get("author_pos_cite_qscore").get("corresponding_author").set("NA", 0);
  }

  if (author.includes('*') || adj_i + 1 === author_list.length) {
      position = "corresponding_author";
      // author_pos_contrib.set("corresponding_author", author_pos_contrib.get("corresponding_author") + 1);
      // author_pos_cite_contrib.set("corresponding_author", author_pos_cite_contrib.get("corresponding_author") + citationCount);
      // author_pos_cite_map.get("corresponding_author").push(citationCount);
      yearwiseData.get(year).get("author_pos_contrib").set("corresponding_author", yearwiseData.get(year).get("author_pos_contrib").get("corresponding_author") + 1);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("corresponding_author", yearwiseData.get(year).get("author_pos_cite_contrib").get("corresponding_author") + citationCount);
      yearwiseData.get(year).get("author_pos_cite_map").get("corresponding_author").push(citationCount);
  } else if (adj_i === 0) {
      position = "first_author";
      // author_pos_contrib.set("first_author", author_pos_contrib.get("first_author") + 1);
      // author_pos_cite_contrib.set("first_author", author_pos_cite_contrib.get("first_author") + citationCount);
      // author_pos_cite_map.get("first_author").push(citationCount);
      yearwiseData.get(year).get("author_pos_contrib").set("first_author", yearwiseData.get(year).get("author_pos_contrib").get("first_author") + 1);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("first_author", yearwiseData.get(year).get("author_pos_cite_contrib").get("first_author") + citationCount);
      yearwiseData.get(year).get("author_pos_cite_map").get("first_author").push(citationCount);
  } else if (adj_i === 1) {
      position = "second_author";
      // author_pos_contrib.set("second_author", author_pos_contrib.get("second_author") + 1);
      // author_pos_cite_contrib.set("second_author", author_pos_cite_contrib.get("second_author") + citationCount);
      // author_pos_cite_map.get("second_author").push(citationCount);
      yearwiseData.get(year).get("author_pos_contrib").set("second_author", yearwiseData.get(year).get("author_pos_contrib").get("second_author") + 1);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("second_author", yearwiseData.get(year).get("author_pos_cite_contrib").get("second_author") + citationCount);
      yearwiseData.get(year).get("author_pos_cite_map").get("second_author").push(citationCount);
  } else if (adj_i > 1 && adj_i + 1 < author_list.length) {
      position = "co_author";
      // author_pos_contrib.set("co_author", author_pos_contrib.get("co_author") + 1);
      // author_pos_cite_contrib.set("co_author", author_pos_cite_contrib.get("co_author") + citationCount);
      // author_pos_cite_map.get("co_author").push(citationCount);
      yearwiseData.get(year).get("author_pos_contrib").set("co_author", yearwiseData.get(year).get("author_pos_contrib").get("co_author") + 1);
      yearwiseData.get(year).get("author_pos_cite_contrib").set("co_author", yearwiseData.get(year).get("author_pos_cite_contrib").get("co_author") + citationCount);
      yearwiseData.get(year).get("author_pos_cite_map").get("co_author").push(citationCount);
  } else {
      console.log("IDX:", publication.index, "Adj idx:", adj_idx, "Author:", author, "Position:", position, "Citations:", citationCount, "QScore:", qscore); //DEBUG
      console.warn(publication.index, publication.author_pos); // DEBUG
  }

  // console.log("IDX:", pub_idx, "Author:", author, "Position:", position, "Citations:", citationCount, "QScore:", qscore); //DEBUG
  // console.warn(pub_idx, publicationData[pub_idx].author_pos); // DEBUG
  // console.log(author_pos_cite_qscore.get(position)); //DEBUG

  yearwiseData.get(year).get("author_pos_cite_qscore").get(position).set(qscore, yearwiseData.get(year).get("author_pos_cite_qscore").get(position).get(qscore) + citationCount);

  // Store the author's position for this publication
  // // publicationAuthorPositions.push(position);
  // // publicationAuthorPositions[pub_idx] = position;
  // publicationAuthorPositions.set(pub_idx, position);
  return position;
}

self.onmessage = async ({ data }) => {
    const { task, batch, authorRegexes, authorRegexesEx, nameComboList, otherNamesList, authorNameShort, authorName, authorNameLong } = data;
    const authorNamesConsidered = [];
    let authorFound = false;
    const yearwiseData = new Map();
    function checkAuthor(author) {
      // Remove special characters from author names (normalize localizations), remvoe puctuation & extra spaces, and convert to lowercase
      const non_specialAuthor_name = replaceSpecialChars(normalizeString(author)).toLowerCase();
      // console.log("checkAuthor():", non_specialAuthor_name, author, authorName, author.toLowerCase().trim() === authorName.toLowerCase().trim(), author.toLowerCase().trim() == authorName.toLowerCase().trim()); // DEBUG
      // console.log("checkAuthor():", non_specialAuthor_name, author, authorName, areEqual(author, authorName)); // DEBUG
      // authorRegexes matches [first initial< wildcard *.>last name]
      // return authorRegexes.test(non_specialAuthor_name) || non_specialAuthor_name.includes(authorNameShort.toLowerCase()) || areEqual(author, authorName);
  
      const regexRes = [];
  
      authorRegexes.forEach((nameRegex) => {
          regexRes.push(nameRegex.test(non_specialAuthor_name));
      });
      regexRes.push(non_specialAuthor_name.includes(authorNameShort.toLowerCase()));
      regexRes.push(areEqual(author, authorName));
  
      regexRes.push(otherNamesList.includes(normalizeString(author.trim())));
      regexRes.push(nameComboList.includes(author.trim()));
  
      return regexRes.some(x => x === true);
    }
    
    try {
      for (const publication of batch) {
       
        const pub_idx = publication.index;
        // const publication = publicationData[pub_idx];
        const authors = publication.authors;
        const citationCount = publication.citations;
        let author_list = authors.split(',').map(author => author.trim());
        // let author_list_filtered = author_list.filter(checkAuthor);

        if (task === 'initialScrape') {
          
          let extended_scrape = false;
          let author_list_filtered = author_list.filter(checkAuthor);

          // console.warn("extended:",pub_idx, author_list_filtered); // DEBUG
          if ((uniq(author_list_filtered).length > 1 || author_list_filtered.length === 0) && authors.includes("...")) {
              // If multiple surnames match, fetch extended author list for clarification
              // urls.push(allURLs[pub_idx]);
              // console.warn("extended:",pub_idx, author_list_filtered); // DEBUG
              // console.warn(pub_idx, publication.title, publication.authors); // DEBUG
              // publicationData[pub_idx].authors = "Pending";
              publication.authors = "Pending";
              publication.considered = false;
              extended_scrape = true;
              continue;
          }

          // publicationProgress += 1;
          // updateLoadingBar((publicationProgress / totalPublications) * 100, "Processing Publications (" + publicationProgress + "): ");
          // // setTimeout(updateLoadingBar, 20, (publicationProgress / totalPublications) * 100, "Processing Publications (" + publicationProgress + "): ");
          // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
          author_list.forEach(async (author, i) => {
          // for (const [i, author] of author_list.entries()) {
              // console.error(author); //DEBUG
              if (author.includes("...")) {
                  // publicationData[pub_idx].authors = "Pending";
                  publication.authors = "Pending";
                  extended_scrape = true;
                  // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
                  return;
              }

              //1st condition in the if() is a special case where extended author info is not available and we have conflicts with the author name/surname (multiple authors with sharmas for eg, n sharma & g sharma)
              const non_specialAuthor_name = replaceSpecialChars(normalizeString(author)).toLowerCase();
              if (non_specialAuthor_name.includes(authorNameShort.toLowerCase()) || non_specialAuthor_name.includes(authorNameLong.toLowerCase()) || areEqual(author, authorName) || otherNamesList.includes(normalizeString(author.trim()))) {
                  // if (authorRegexes.test(non_specialAuthor_name)) {
                  const regexInitial = [];
                  authorRegexes.forEach((name) => {
                      regexInitial.push(name.test(non_specialAuthor_name));
                  });
                  regexInitial.push(otherNamesList.includes(normalizeString(author.trim())));
                  if (regexInitial.some(x => x === true)) {
                      authorFound = true;
                      // if author name is processed, add to authorNamesConsidered list after stripping punctuation and extra spaces
                      const authorTrimmed = author.replace(/[\*\^']|_/g, "").replace(/\s+/g, " ").trim();

                      // if (!authorNamesConsidered.includes(authorTrimmed)) {
                          authorNamesConsidered.push(authorTrimmed);
                      // }
                      publication.author_pos = processAuthorPositions(yearwiseData, author, author_list, citationCount, i, publication.journalRanking, publication.year, pub_idx, publication);
                      publication.total_authors = author_list.length;
                      publication.considered = true;
                  }
              }
              // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
          });

          // if(publication.year.toString().trim().length === 0){
          //     pub_no_year += 1;
          // }

          // if (!yearwiseData.get(publication.year).has("total_publications")) {
          //     yearwiseData.get(publication.year).set("total_publications", 0);
          // }
          // yearwiseData.get(publication.year).set("total_publications", yearwiseData.get(publication.year).get("total_publications") + 1);

          if (!authorFound) {
              // console.warn(pub_idx, publication.title, publication.authors); // DEBUG
              // publicationData[pub_idx].authors = "Pending";
              publication.authors = "Pending";
              extended_scrape = true;
          }

          // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
          self.postMessage({ type: 'working' , task: 'initialScrape', authorRegexes: authorRegexes, authorFound: authorFound, extended_scrape: extended_scrape, publication: publication });
        }else if(task === 'extendedScrape'){
          
          function checkAuthorExtended(author) {
            // Remove special characters from author names (normalize localizations), remvoe puctuation & extra spaces, and convert to lowercase
            const non_specialAuthor_name = replaceSpecialChars(normalizeString(author)).toLowerCase();
            // console.log("checkAuthorExtended():", non_specialAuthor_name, author, authorName, author.toLowerCase().trim() === authorName.toLowerCase().trim(), author.toLowerCase().trim() == authorName.toLowerCase().trim()); // DEBUG
            // console.log("checkAuthorExtended():", non_specialAuthor_name, author, authorName, areEqual(author, authorName)); // DEBUG
            // authorRegexesEx matches [first name< wildcard *.>last name]
            // return authorRegexesEx.test(non_specialAuthor_name) || areEqual(author, authorName);
        
            const regexRes = [];
        
            authorRegexesEx.forEach((name) => {
                regexRes.push(name.test(non_specialAuthor_name));
            });
            regexRes.push(areEqual(author, authorName));
        
            regexRes.push(otherNamesList.includes(normalizeString(author.trim())));
            regexRes.push(nameComboList.includes(author.trim()));
        
            return regexRes.some(x => x === true);
          }
          
          let extended_check = true;
          let author_list = authors.split(',').map(author => author.trim());
          let author_list_filtered = author_list.filter(checkAuthorExtended);

          if (author_list_filtered.length === 0) {
              // console.warn("extended:",pub_idx, author_list_filtered); // DEBUG
              // In a lot of cases, the full names are not retrieved even from the extended author information so we revert back to simple author name matching to include them
              // console.warn(pub_idx, publication.title, publication.authors); // DEBUG
              author_list_filtered = author_list.filter(checkAuthor);
              extended_check = false;
              // console.warn("simple:", pub_idx, author_list_filtered); // DEBUG
          }

          const regexToUse = extended_check ? authorRegexesEx : authorRegexes;

          if (author_list_filtered.length === 0 || publication.authors === "Authors not found") {
              // console.warn("extended - 1",pub_idx, publication.title, publication.authors); // DEBUG
              // publicationAuthorPositions.set(pub_idx, "NA");
              // console.log("Before:", pub_author_no_match); //DEBUG
              // pub_author_no_match += 1;
              // console.log(publication.authors); //DEBUG
              authorFound = false;
              publication.considered = false;
              // console.log("After:", pub_author_no_match); //DEBUG
          } else {

              // author_list.forEach(async (author, i) => {
              for (const [i, author] of author_list.entries()) {
                  const non_specialAuthor_name = replaceSpecialChars(normalizeString(author)).toLowerCase();
                  if (non_specialAuthor_name.includes(authorNameShort.toLowerCase()) || non_specialAuthor_name.includes(authorNameLong.toLowerCase()) || areEqual(author, authorName) || otherNamesList.includes(normalizeString(author.trim()))) {
                      // if (regexToUse.test(non_specialAuthor_name)) {
                      const regexExtended = [];
                      regexToUse.forEach((name) => {
                          regexExtended.push(name.test(non_specialAuthor_name));
                      });
                      // authorRegexes.forEach((name) => {
                      //     regexExtended.push(name.test(non_specialAuthor_name));
                      // });
                      // authorRegexesEx.forEach((name) => {
                      //     regexExtended.push(name.test(non_specialAuthor_name));
                      // });
                      regexExtended.push(otherNamesList.includes(normalizeString(author.trim())));

                      if (regexExtended.some(x => x === true)) {
                          authorFound = true;
                          processedPubsIdx.add(pub_idx);
                          //if author name is processed, add to authorNamesConsidered list after stripping punctuation and extra spaces
                          const authorTrimmed = author.replace(/[^\w\s\']|_/g, "").replace(/\s+/g, " ").trim();
                          // if (!authorNamesConsidered.includes(authorTrimmed)) {
                              authorNamesConsidered.push(authorTrimmed);
                          // }

                          // console.warn("extended - FOUND",pub_idx, publication.title, publication.authors); // DEBUG

                          // Process author positions based on roles (e.g., first author, co-author)
                          publication.author_pos = processAuthorPositions(yearwiseData, author, author_list, citationCount, i, publication.journalRanking, publication.year, pub_idx, publication);

                          publication.total_authors = author_list.length;

                          
                          // tsvContent += `${publication.index}\t${publication.title}\t${publication.authors}\t${publication.authors.includes("...") ? `${publication.total_authors - 1}+` : publication.total_authors}\t${publication.year}\t${publication.citations}\t${adjustedCitationCount}\t${citationWeight}\t${publication.journalTitle}\t${publication.journalRanking}\t${publication.impact_factor}\t1\t${author_pos_string}\n`; // Add each publication in a new row
                          publication.author_pos_string = author_pos_string;
                          publication.adjustedCitationCount = adjustedCitationCount;
                          publication.citationWeight = citationWeight;
                          publication.considered = true;
                      }
                  }
                  // await new Promise(r => setTimeout(r, 0));  // Allow other tasks to run
              }//);

              


          }

          self.postMessage({ type: 'working' , task: 'extendedScrape', authorRegexes: authorRegexes, authorRegexesEx: authorRegexesEx, authorFound: authorFound, extended_check: extended_check, publication: publication });
        }
      }
      self.postMessage({ type: 'done' , task: task , yearwiseData: yearwiseData, authorNamesConsidered: authorNamesConsidered });
    } catch (err) {
      self.postMessage({ type: 'error', task, error: err.message });
    }
  };